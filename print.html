<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Asteracea</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

		<!-- Plausible analytics -->
		<script async defer data-domain="schichler.dev" src="https://plausible.io/js/plausible.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="0_sneak_peek.html"><strong aria-hidden="true">2.</strong> 0: Sneak Peek</a></li><li class="chapter-item expanded "><a href="static_components/index.html"><strong aria-hidden="true">3.</strong> 1: Static Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static_components/empty_component.html"><strong aria-hidden="true">3.1.</strong> An Empty Component</a></li><li class="chapter-item expanded "><a href="static_components/rust_comments.html"><strong aria-hidden="true">3.2.</strong> Rust Comments</a></li><li class="chapter-item expanded "><a href="static_components/html_comments.html"><strong aria-hidden="true">3.3.</strong> HTML Comments</a></li><li class="chapter-item expanded "><a href="static_components/text.html"><strong aria-hidden="true">3.4.</strong> Text</a></li><li class="chapter-item expanded "><a href="static_components/elements.html"><strong aria-hidden="true">3.5.</strong> Elements</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Attributes</div></li><li class="chapter-item expanded "><a href="static_components/child_components.html"><strong aria-hidden="true">3.7.</strong> Child Components</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Value Formatting</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Rust Blocks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> CSS Scoping</div></li><li class="chapter-item expanded "><a href="static_components/ex_stateless_components_are_zero-sized.html"><strong aria-hidden="true">3.11.</strong> EX: Stateless Components are Zero-Sized</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 2: Dynamic Components</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="dynamic_components/new_with.html"><strong aria-hidden="true">4.1.</strong> new with { …; }</a></li><li class="chapter-item expanded "><a href="dynamic_components/gui_error_and_backtrace.html"><strong aria-hidden="true">4.2.</strong> GUIError and &quot;backtrace&quot;</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Render Parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Constructor Parameters</div></li><li class="chapter-item expanded "><a href="dynamic_components/predefined_lifetimes.html"><strong aria-hidden="true">4.5.</strong> Predefined Lifetimes</a></li><li class="chapter-item expanded "><a href="dynamic_components/conditional_attributes.html"><strong aria-hidden="true">4.6.</strong> Conditional Attributes</a></li><li class="chapter-item expanded "><a href="dynamic_components/argument_defaults.html"><strong aria-hidden="true">4.7.</strong> Argument Defaults</a></li><li class="chapter-item expanded "><a href="dynamic_components/optional_arguments.html"><strong aria-hidden="true">4.8.</strong> Optional Arguments</a></li><li class="chapter-item expanded "><a href="dynamic_components/conditional_child_component_parameters.html"><strong aria-hidden="true">4.9.</strong> Conditional Child Component Parameters</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.10.</strong> Persistence 1: Constructor Parameter Captures</div></li><li class="chapter-item expanded "><a href="dynamic_components/body_captures.html"><strong aria-hidden="true">4.11.</strong> Persistence 2: Body Captures</a></li><li class="chapter-item expanded "><a href="dynamic_components/dependency_extraction.html"><strong aria-hidden="true">4.12.</strong> Dependency Extraction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.</strong> Event Handlers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Fallible Components</div></li><li class="chapter-item expanded "><a href="dynamic_components/with.html"><strong aria-hidden="true">4.15.</strong> with { …; } &lt;…&gt;</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 3: Conditional Content</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> .param =&gt; &lt;…&gt;</div></li><li class="chapter-item expanded "><a href="conditional_content/spread_if.html"><strong aria-hidden="true">5.2.</strong> spread if {…} &lt;…&gt;</a></li><li class="chapter-item expanded "><a href="conditional_content/spread_if_else.html"><strong aria-hidden="true">5.3.</strong> spread if …… else &lt;…&gt;</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> dyn if {…} ⟦as ⟦pub⟧ …⟦: ⟦enum⟧ …⟧⟧ ⟦dyn ⟦move⟧⟧ &lt;…&gt; ⟦else ⟦dyn ⟦move⟧⟧ &lt;…&gt;⟧</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> for … in &lt;…&gt; by &lt;…&gt; ⟦priv …⟦: ⟦struct⟧ …⟧⟧ &lt;…&gt; ⟦else &lt;…&gt;⟧</div></li><li class="chapter-item expanded "><a href="conditional_content/spread_match.html"><strong aria-hidden="true">5.6.</strong> spread match &lt;…&gt; [ … ]</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> dyn match &lt;…&gt; [ … ]</div></li><li class="chapter-item expanded "><a href="conditional_content/box.html"><strong aria-hidden="true">5.8.</strong> box ⟦priv …⟦: ⟦struct⟧ … ⟦where …;⟧⟧⟧ &lt;…&gt;</a></li><li class="chapter-item expanded "><a href="conditional_content/defer_move_as.html"><strong aria-hidden="true">5.9.</strong> defer ⟦priv …⟦: ⟦struct⟧ …⟧⟧ ⟦dyn ⟦move⟧⟧ &lt;…&gt;</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 4: Modifiers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Introduction to VDOM Modifiers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> CSS Scoping</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 5: Miscellaneous</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="misc/glossary.html"><strong aria-hidden="true">7.1.</strong> Glossary</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Embdedding JavaScript Components</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 6: Integrating Asteracea</div></li><li class="chapter-item expanded "><a href="ex_hello_asteracea.html"><strong aria-hidden="true">9.</strong> EX: Hello Asteracea</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">
						Asteracea
						<span style="color: red;" aria-label="[WIP: Expect breaking and URL changes!]" title="Automatically generated from the develop branch. Expect breaking and URL changes!">[WIP]</span>
					</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the Asteracea guide book!</p>
<blockquote>
<p><strong>This book is a work in progress!</strong></p>
<p>Until the first minor version stabilisation, there likely will only be this <code>develop</code>-branch version published online as rendered version, which usually won't mach a version of the crate published to crates.io. (Respective versions are tagged and can be rendered offline using (from the repository's root directory) <code>cd book</code> and <code>cargo run</code>.)</p>
<p>In addition to the missing chapters, URLs are subject to change, links have have not been filled in and code blocks without highlighting or rendered HTML output may show unimplemented features.</p>
</blockquote>
<h2><a class="header" href="#audience" id="audience">Audience</a></h2>
<p>While using Asteracea effectively requires knowledge of Rust, this book is written also with non-Rustaceans in mind.</p>
<p>If you have experience with more traditional front-end frameworks like Angular or React, quite a few of the presented concepts should be familiar to you. I will also try to highlight these connections where they appear. By the end of the book, you should be able to read Asteracea's component templates and make modifications to them.</p>
<p>If you are already familiar with Rust, you can use the samples from <a href="TK">Chapter 6: Integrating Asteracea</a> to create a complete web site or application including static site generation, server-side rendering and/or a (primary or optional) client-side approach.</p>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>When I started using Rust privately in 2019, I had worked as a consultant on multiple web projects, mainly as front-end developer using TypeScript, Angular and React. I had grown increasingly frustrated with the failure classes of this weakly typed ecosystem: Aside from (rare but in those cases often destructive) run-ins with outdated or wrong type definitions for external packages, it was too easy to accidentally turn off type checking. It was often easy to forget to handle certain failure cases. React was quick to prototype in, but would often spiral in complexity and unchecked definitions on larger projects. Angular applications were comparatively robust but required manual subscription management to prevent memory leaks and required a significant amount of boilerplate that couldn't be abstracted away due to compiler limitations.</p>
<p>Meanwhile on the server side, Spring Boot was resource-hungry as a microservice platform, requiring powerful development systems to run a local test instance of the platform even without any data added to it. Using the documentation was also frustrating to me, since it was difficult to look up the various implicit behaviours. I wouldn't be able to work efficiently with such a system on my slower home computer that also needed to handle a considerable amount of browser tabs at the same time. To top it off, DTOs couldn't be easily shared through the various layers of the application.</p>
<p>I originally got into Rust to have another go at game development. This didn't go well at the time due to lack of high-level frameworks I could prototype something in quickly, but I liked the language and ended up writing several smaller utility programs. Then I had to switch Android ROMs to still get updates and lost the data stored in the finance tracker app I was using. (Backups were only available by uploading my data to the manufacturer's servers, which I decided against.) I took this as an opportunity to write my own tracker, to be hosted on a Pi Zero W so I could make entries from my phone. In part to learn about technologies I had seen but not used myself at work, I decided to use a network of Docker containers, with Postgres for storage and Nginx to serve static files and act as reverse proxy.</p>
<p>While this tracker project is currently stalled, with help from friends I still managed to create a successful prototype: With <a href="https://diesel.rs/">Diesel</a>, [Serde] and by <a href="https://www.rust-lang.org/what/wasm">targeting WebAssembly</a>, I could reuse a single DTO definition all the way from Diesel to the app's browser frontend. Resource usage was tiny, requiring only about 15MB of private RAM and less than 0.5% CPU for the entire idling prototype server! I was also looking forward to drop JSON from my stack when MsgPack and CBOR inspection was added to Firefox.</p>
<p>However, here is where I hit a snag: I was used to relatively mature web frameworks that make it easy to write reusable components and test them in isolation via dependency injection. I was also looking for CSS scoping and to ideally <em>never</em> touch JavaScript myself (ideally skipping its build ecosystem entirely). I used version <code>0.1.0</code> of <a href="https://lib.rs/crates/dodrio"><code>dodrio</code></a> for a while, but as stated on its project page, it's not intended as complete GUI solution. <a href="https://github.com/hecrj/iced">Iced</a> wasn't a good fit due to being more high-level than what I was going for. <a href="https://github.com/bodil/typed-html"><code>typed-html</code></a> seemed close to what React does, but I was looking for more stateful component tooling. (<code>dodrio</code> inspired Asteracea's use of a bump allocator.)</p>
<p>(<a href="https://github.com/extraymond/afterglow">Afterglow</a> did not exist at that point. You will probably want to look at it as an alternative before deciding what to go with. Its design goals seem different from Asteracea's, at a glance.)</p>
<p>I decided to write my own solution to this problem, which is where things started to escalate.</p>
<h2><a class="header" href="#asteraceas-design-goals" id="asteraceas-design-goals">Asteracea's Design Goals</a></h2>
<p>Asteracea is, as of October 2020, still early in development and subject to change. However, there are a few main goals I want to enable with this framework that can be put into writing already:</p>
<ul>
<li>
<p>Low boilerplate:</p>
<p>Web components have a certain shape that's shared between each of them. Creating a new component shouldn't require a large amount of text to get started, so that the focus is on what the individual component does.</p>
<p>A completely empty component, minus the outer macro call, can be written as concisely as <a href="./static_components/empty_component.html"><code>E()()[]</code></a>. This generates a (zero-size) model, a (practically empty) constructor and a render method that generates an empty element group - a VDOM node that results in no output. More complex components grow naturally from here.</p>
<p>Formatting a value into the output can be as simple as <a href=""><code>!{value}</code></a>. More on all this later.</p>
</li>
<li>
<p>Straightforward macros:</p>
<p>While Asteracea relies heavily on procedural macros, these macros aren't magic. By and large, Asteracea does a copy-and-paste source code transformation. (Some dynamic defaults exist. Criticism is welcome.)</p>
<p>Code spans are preserved as much as possible, so if the input is valid to Asteracea but the output is invalid Rust, the relevant errors and warnings will appear in matching locations on the macro input.</p>
</li>
<li>
<p>Inclusive runtime:</p>
<p>At some point during development, Twitter made its new web interface mandatory for all users. As of October 2020, it is still quite heavy (topping <code>about:perfomance</code> in Firefox by a wide margin alongside YouTube), loads slowly, is next to impossible to style, occasionally glitchy and does not work whatsoever without JavaScript enabled.</p>
<p>Asteracea can't take care of all of these things for you, but I'm proud to announce that serverside-rendering and static site generation are supported without specifically adjusting the application code. The clientside version of the app can then hydrate the existing DOM structure, whether seamlessly or with additional content not included in the static version.</p>
<p>Asteracea has no signature pattern aside from capitalising element names (which saves on some runtime branching). Generated HTML and DOM are structured as if written by hand.</p>
</li>
<li>
<p>Balancing safety, simplicity and generality:</p>
<p>Asteracea inherits its safety and lifetime model from Rust, with the one part not validated by the compiler being the render loop, external to the core framework and main application code. This is due to interaction with the browser DOM at this point, though a different implementation using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry"><code>FinalizationRegistry</code></a> may be possible there.</p>
<p>The targeted application model is single-threaded, which means components and event handlers aren't required to be <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> or <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code>Sync</code></a>.</p>
<p>Event handlers are only required to be valid for one render cycle (though reusing closures is encouraged and done by the basic event handler syntax). Component instances are required to outlive event handlers, but their lifetime is otherwise unconstrained by default. In particular, you can usually drop component instances before their rendered VDOM iff they don't register event handlers.</p>
<p>Any expression between curly brackets (<code>{}</code>) in the templates is plain old Rust: The code is always¹ pasted verbatim and you can use any and all Rust features in those locations.</p>
<p>¹ This is technically only effectively true: A small but limited find-and-replace transformation is applied to event handlers to enable using <code>self</code> within them. It should match expected Rust behaviour under all circumstances, though.</p>
<p>Asteracea is named after the family of <a href="https://en.wikipedia.org/w/index.php?title=Asteraceae&amp;oldid=982133740">Asteraceae</a>, which contains very spectacular as well as very inconspicuous, but generally quite practical flowers. My hope is that this set of libraries will eventually be used for a similarly wide range of applications.</p>
</li>
</ul>
<h1><a class="header" href="#chapter-0-sneak-peek" id="chapter-0-sneak-peek">Chapter 0: Sneak Peek</a></h1>
<p>Before I begin to explain in earnest, here is a relatively complex dynamic component using many of Asteracea's features, along with its resulting HTML representation:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::Cell;

fn schedule_render() { /* ... */ }

asteracea::component! {
  pub Counter(
    initial: i32,
    priv step: i32,
    pub enabled: bool = true,
  )(
    class?: &amp;'bump str,
  )

  |value = Cell::&lt;i32&gt;::new(initial)|;

  //

  &lt;div
    .&quot;class&quot;? = {class}
    &quot;The current value is: &quot; !{self.value()} &lt;br&gt;

    &lt;button
      .&quot;disabled&quot;? = {!self.enabled}
      &quot;+&quot; !{self.step}
      +&quot;click&quot; {self.step()}
    &gt;
  &gt;
}

//

impl Counter {
  pub fn value(&amp;self) -&gt; i32 {
    self.value.get()
  }

  pub fn set_value(&amp;self, value: i32) {
    self.value.set(value);
    schedule_render();
  }

  fn step(&amp;self) {
    self.value.set(self.value() + self.step);
    schedule_render();
  }
}

asteracea::component! {
  pub CounterUser()()

  &lt;&quot;counter-user&quot; &quot;\n\t&quot;
    &lt;*Counter
      *initial = {0}
      *step = {1}
    &gt; &quot;\n&quot;
  &gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;counter-user&gt;
	&lt;DIV&gt;The current value is: 0&lt;BR&gt;&lt;BUTTON&gt;+1&lt;/BUTTON&gt;&lt;/DIV&gt;
&lt;/counter-user&gt;
</code></pre>
<p>This guide assumes you have done some web development before, so some parts of the template should look familiar to you.</p>
<p>Others probably look pretty unfamilar, even with both a web development and Rust background. I removed some redundant grammar and had to invent new syntax for some features that don't appear as such in either ecosystem.</p>
<p>Overall, I like to call this an MVC lite approach: You can see the model, view and controller parts of the component, in this order, without them being separated into different files. I've marked the boundaries between parts with a Rust comment each (<code>//</code>).</p>
<p>This actually isn't mandatory - Asteracea is quite flexible and lets you mix them when appropriate - but it's a good way to clean up larger components that otherwise wouldn't fit on the screen well.</p>
<p>There's also syntax highlighting without extra tools! The version here in the book is simplified, but if you use <a href="https://rust-analyzer.github.io/">rust-analyzer</a>, then it's really quite smart.</p>
<p>The following chapters will teach you how to read and write these components, though becoming fluent may require a little bit of practice.</p>
<h1><a class="header" href="#chapter-1-static-components" id="chapter-1-static-components">Chapter 1: Static Components</a></h1>
<p>Asteracea, <a href="https://reactjs.org/docs/components-and-props.html#function-and-class-components">unlike for example React</a>, does not have multiple ways to define a component depending on whether you'd like to use instance state or not¹. Instead, due to low syntactic overhead and Rust's efficiency, <code>struct</code> components are generated throughout.</p>
<p>Stateless <code>struct</code> components have zero runtime overhead compared to functions equivalent <a href="static_components/TK"><code>fragment!</code></a> use. This, along with less boilerplate and for consistency, is why I generally recommend <a href="static_components/TK"><code>component!</code></a> for all reusable GUI elements.</p>
<p>In this chapter, I will introduce the basics of generating various virtual DOM nodes in Asteracea, which can then be translated into (e.g.!) HTML or browser DOM elements.</p>
<p>¹ The distinction has weakened in React recently. Asteracea's approach to stateful components is <a href="static_components/./2_5_body_captures.html">partially inspired</a> by React's Hooks in terms of UX, but is implemented very differently below the surface.</p>
<h1><a class="header" href="#an-empty-component" id="an-empty-component">An Empty Component</a></h1>
<p>As mentioned in the introduction, the simplest Asteracea component is <code>E()()[]</code>.</p>
<p>In context, and written more like what you'd see in the wild:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Empty()()

  []
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">
</code></pre>
<p>(All Asteracea component examples are followed by their output as rendered by <a href="https://github.com/Tamschi/lignin-html"><code>lignin-html</code></a>, but in this case it's an empty string.)</p>
<p>This component expands to the following Rust code, with <code>use</code> imports extracted by hand and a little manual formatting:</p>
<pre><code class="language-rust no_run noplayground">//TODO
</code></pre>
<p>As you can see, the <code>component!</code> macro created one <code>struct</code> type, with one constructor called <code>new</code> and one method called <code>render</code>. The output of <code>component!</code>, as far as you're supposed to touch it, <strong>always</strong> has this shape. No exceptions.</p>
<p>(The macro can currently, under certain circumstances, create colliding definitions of structs called <code>NewStatics</code> and <code>RenderStatics</code>. This is a bug and will be fixed prior to release.</p>
<p>If this happens to you, place your components in different modules. These types are not part of the public interface, and strictly speaking not something you're supposed to touch explicitly, and won't interfere further than this.)</p>
<p>The parentheses around the body of render aren't strictly needed here... and you may find small bits of similar useless syntax in other positions too. The most simple explanation is that they're leftovers that will be cleaned up eventually (when more tests exist), but sometimes these pieces of code nudge Rust into giving you a better error message or block off certain edge cases (usually inner attributes) that either would be confusing to read or haven't been properly evaluated yet.</p>
<h2><a class="header" href="#the-breakdown" id="the-breakdown">The breakdown</a></h2>
<p>There are five distinct pieces of syntax that are translated into the output here: <code>pub</code>, <code>Empty</code>, <code>()</code>, <code>()</code> and <code>[]</code>.</p>
<h3><a class="header" href="#pub-visibility" id="pub-visibility"><code>pub</code> (visibility)</a></h3>
<p>This is a plain <a href="https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html?highlight=pub#visibility-and-privacy">Rust visibility</a> and inserted just before the <code>struct</code> keyword in the macro output above, controlling where the component can be used directly. Leave it out to for current-module-only visibility.</p>
<p><code>new</code> and <code>render</code> are always declared <code>pub</code>; They inherit their visibility from the component structure.</p>
<h3><a class="header" href="#empty-component-name" id="empty-component-name"><code>Empty</code> (component name)</a></h3>
<p>This identifier is inserted verbatim into the output as shown.</p>
<p>There aren't any requirements regarding <em>which</em> identifier to use, but I encourage you to avoid generic suffixes like &quot;<code>…Component</code>&quot;.</p>
<p>Consider e.g. &quot;<code>…ListItem</code>&quot;, &quot;<code>…Button</code>&quot; or, if nothing more specific applies, &quot;<code>…Panel</code>&quot; as more descriptive alternatives, or leave the suffix off entirefly if there's no confusion regarding which types are components and which are not.</p>
<h3><a class="header" href="#-constructor-argument-list" id="-constructor-argument-list"><code>()</code> (constructor argument list)</a></h3>
<p>This is the first pair of parenthese in the input and also appears before the other in the output. As you can see, it is inserted verbatim after <code>new</code> here.</p>
<p>You can use any normal argument declaration here, with the exception of <code>self</code> parameters.</p>
<p>The constructor argument list also supports a shorthand to declare and assign fields on the component instance, but more on that [later].</p>
<h3><a class="header" href="#-render-argument-list" id="-render-argument-list"><code>()</code> (render argument list)</a></h3>
<p>The second pair of parentheses is used to declare <strong>additional</strong> render arguments.</p>
<p>This one is never pasted verbatim into the resulting component, despite supporting only plain Rust argument declarations (with the exception of <code>self</code> parameters and, usually, <code>bump</code>).</p>
<p>Instead, its items are inserted at the end of <code>render</code>'s argument list above, after the implicit arguments <code>&amp;self</code> and <code>bump: &amp;'bump Bump</code>. You can access instance fields through <code>self</code> in the component body (more on that later) and <code>bump</code> is a <a href="https://docs.rs/bumpalo/3/bumpalo/struct.Bump.html"><code>Bump</code></a> from <a href="https://github.com/fitzgen/bumpalo"><code>bumpalo</code></a>, a bump allocation arena that makes the VDOM more efficient.</p>
<p><strong>Do not place anything into <code>bump</code> that needs to be dropped!</strong> Bump allocators are speedy, but this speed is bought by not running any logic before the memory is reused. Some workarounds for common use cases exist, but for the most part Asteracea handles this for you. See <a href="https://github.com/fitzgen/bumpalo"><code>bumpalo</code></a>'s documentation for more information.</p>
<h3><a class="header" href="#-body--empty-multi-node" id="-body--empty-multi-node"><code>[]</code> (body / empty Multi Node)</a></h3>
<p>The location of <code>[]</code> in this example component is called the <strong>body</strong> of the component.</p>
<p><code>[]</code> itself is an <strong>empty Multi Node</strong>, which expands to <code>Node::Multi(&amp;*bump.alloc_with(|| []))</code>.</p>
<p>The contents of this node are placed in the bump allocation arena which, in this case, is effectively no operation. Location and length of this list are stored in the containing [<code>Node</code>], which here is returned directly from <code>render</code>.</p>
<p>It's legal to reuse [<code>Node</code>] instances in multiple places in the VDOM tree. You can also cache long-lived [<code>Node</code>]s and then refer to them across multiple render cycles, to avoid re-rendering part of the VDOM.</p>
<p><strong>Multi Nodes</strong> are a VDOM concept that doesn't translate into DOM: Their contents are replicated without nesting in the surrounding DOM structure. You can use them, for example, to return multiple elements at the top level of a component.</p>
<p>Another use is to represent a variable number of elements, including none. The diffing algorithm in <a href="https://github.com/Tamschi/lignin-dom"><code>lignin-dom</code></a> advances by a single VDOM sibling when processing a multi node. This means that you can avoid shifting any following sibling nodes, which can avoid expensively recreating their DOM representation or confusing the user by moving their selection to an unexpected place.</p>
<h1><a class="header" href="#rust-comments" id="rust-comments">Rust Comments</a></h1>
<p>You can use three distinct types of comments in Asteracea macros, all serving different purposes:</p>
<p>First, standard Rust comments can be placed anywhere in Asteracea components (or any other place in a Rust program), and are not included in the compiled binary:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Commented()()

  [
    // This is a one-line comment.
    /*
    /* These are *nested* multiline comments. */
    */
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">
</code></pre>
<p>Additionally, Rust documentation is supported in many places:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  /// This is a documented component.  
  /// Running `cargo doc` will pick up on its documentation.
  pub Documented()()

  []
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">
</code></pre>
<p>These <code>///</code> (or <code>//!</code>) annotations are not included in the compiled binary either¹, but can be picked up by standard Rust tooling like <a href="https://rust-analyzer.github.io/">rust-analyzer</a>.</p>
<p>¹ Rare exceptions in combination with other macros apply.</p>
<h1><a class="header" href="#html-comments" id="html-comments">HTML comments</a></h1>
<p>The third kind of comment is specific to Asteracea and does affect program output:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub HtmlCommented()()

  &lt;!-- &quot;This is an HTML comment.&quot; --&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;!--This is an HTML comment.--&gt;
</code></pre>
<p>The double quotes are a Rust limitation: Since Rust tokenises macro input, a string literal is required to extract raw text.</p>
<p>You can use a multiline string to easily write a multiline HTML comment:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub HtmlCommented()()

  &lt;!-- &quot;
    This comment spans mul-
    tiple lines, I hope it is
    not too annoying.
  &quot; --&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;!--
    This comment spans mul-
    tiple lines, I hope it is
    not too annoying.
  --&gt;
</code></pre>
<h1><a class="header" href="#text" id="text">Text</a></h1>
<p>To output a static plain <a href="https://developer.mozilla.org/en-US/docs/Web/API/Text"><code>Text</code></a> element in Asteracea, simply use a text literal in your component's body:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Text()()

  &quot;This is text.&quot;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">This is text.
</code></pre>
<p>The macro output is largely the same as for the <code>Empty</code> component, but the <code>render</code> method has changed:</p>
<pre><code class="language-rust no_run noplayground">use lignin::Node;

<span class="boring">pub struct Text {}
</span><span class="boring">impl Text {
</span><span class="boring">pub fn new() -&gt; Self {
</span><span class="boring">  Self {}
</span><span class="boring">}
</span>// …
// TODO
// …
<span class="boring">}
</span></code></pre>
<p>(Click the eye icon to view the rest of the macro output. Note that this also displays a hidden <code>main</code> method inserted by mdBook which isn't part of <code>component!</code>'s output.)</p>
<h2><a class="header" href="#multiple-text-elements" id="multiple-text-elements">Multiple <code>Text</code> elements</a></h2>
<p>Text nodes can be used as children of other nodes, for example a Multi Node:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub TextMulti()()

  [
    &quot;This is text.&quot;
    &quot;This is also text.&quot;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">This is text.This is also text.
</code></pre>
<pre><code class="language-rust no_run noplayground">use lignin::{bumpalo::Bump, Node};

<span class="boring">pub struct TextMulti {}
</span><span class="boring">impl TextMulti {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Self {}
</span><span class="boring">    }
</span>// …
pub fn render&lt;'bump&gt;(
    &amp;self,
    bump: &amp;'bump Bump,
) -&gt; Node&lt;'bump&gt; {
    (Node::Multi(&amp;*bump.alloc_with(|| {
        [
            Node::Text(&quot;This is text.&quot;),
            Node::Text(&quot;This is also text.&quot;),
        ]
    })))
}
// …
<span class="boring">}
</span></code></pre>
<p>Note that there is no space between the sentences in the generated HTML.</p>
<p>Asteracea gives you fairly precise control over the output, but that also means it won't make changes to the document's whitespace for you. If there's no whitespace in the literal in the input, then there won't be whitespace in the content of the output (when rendering with <a href="https://github.com/Tamschi/lignin-html">lignin-html</a> or <a href="https://github.com/Tamschi/lignin-dom">lignin-dom</a>).</p>
<p>There is one important difference between the HTML and DOM output of adjacent sibling Text nodes: In HTML, it is impossible to distinguish them and browsers will parse them as single DOM node. When manipulating the DOM directly, the distinct text nodes will be preserved.</p>
<p>This is one of the reasons that a client-side renderer must once parse the existing DOM into a VDOM when hydrating an app. Another good reason is that user-supplied browser extensions may have made changes to the DOM tree.</p>
<p>(<strong>Please don't render into <code>&lt;body&gt;</code> directly!</strong> Many browser extensions insert their own scripts or overlays as child elements here.</p>
<p>While it's not too likely that these additions will make your app crash, the GUI may glitch and appear for example duplicated. Rendering into, for example, a <code>&lt;div id=app&gt;</code> instead is more reliable.)</p>
<p>Multi Nodes generated by Asteracea macros always place their contents in the bump allocation arena, even if those contents are theoretically immutable.</p>
<h1><a class="header" href="#elements" id="elements">Elements</a></h1>
<p>To define elements and their contents, Asteracea provides a syntax similar to HTML:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Div()()

  &lt;div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;/DIV&gt;
</code></pre>
<p><code>&lt;name</code> opens an element and <code>&gt;</code> is enough to close one. However, you can alternatively close elements with <code>/name&gt;</code> too, which the compiler will validate:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Div()()

  &lt;div
    // [complex nested template]
  /div&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;/DIV&gt;
</code></pre>
<p>Elements can contain any number of valid Asteracea component bodies, which are rendered as the element's children, as long as the specific element supports it:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Span()()

  &lt;span
    &quot;This is text within a &lt;span&gt;.&quot;
    &lt;!-- &quot;This is a comment within a &lt;span&gt;.&quot; --&gt;
  &gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;SPAN&gt;This is text within a &amp;lt;span&gt;.&lt;!--This is a comment within a &amp;lt;span&amp;gt;.--&gt;&lt;/SPAN&gt;
</code></pre>
<p>This includes other elements:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub DivSpan()()

  &lt;div
    &lt;span &quot;This is text within a &lt;span&gt;.&quot;&gt;
  &gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;SPAN&gt;This is text within a &amp;lt;span&gt;.&lt;/SPAN&gt;&lt;/DIV&gt;
</code></pre>
<p>Elements are statically validated against <a href="static_components/TK"><code>lignin-schema</code></a>.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Glossary/empty_element">Empty elements</a> like <code>&lt;br&gt;</code> are written like any other element, but don't accept children and won't render a closing tag to HTML when using <a href="static_components/TK">lignin-html</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Br()()

  &lt;br&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;BR&gt;
</code></pre>
<p>To use custom element names without validation, quote them like this:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Custom()()

  &lt;&quot;custom-element&quot;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;custom-element&gt;&lt;/custom-element&gt;
</code></pre>
<h1><a class="header" href="#child-components" id="child-components">Child Components</a></h1>
<p>Asteracea components can be used inside other templates using asterisk syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: Hide this initially.
use std::marker::PhantomData;

asteracea::component! {
  Inner()()
  &quot;Inner body.&quot;
}

mod module {
  asteracea::component! {
    pub Module()()
    &quot;Module body.&quot;
  }
}

asteracea::component! {
  Generic&lt;T&gt;(
    //TODO: Hide this initially and show an ellipsis comment.
    // Generic parameters must be used in an instance field.
    // We can pretend this is the case using a constructor parameter capture.
    // `PhantomData` is a type that provides fake storage semantics.
    priv _phantom: PhantomData&lt;T&gt; = PhantomData::default(),
  )()
  &quot;Generic body.&quot;
}

asteracea::component! {
  Outer()()

  [
    &lt;*Inner&gt; &quot;\n&quot;
    &lt;*module::Module&gt; &quot;\n&quot;
    &lt;*Generic::&lt;()&gt;&gt; // Mind the turbofish! ::&lt;&gt; 🐟💨
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Inner body.
Module body.
Generic body.
</code></pre>
<p>Explicit closing is supported:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: Hide repetition.
use std::marker::PhantomData;

asteracea::component! {
  Inner()()
  &quot;Inner body.&quot;
}

mod module {
  asteracea::component! {
    pub Module()()
    &quot;Module body.&quot;
  }
}

asteracea::component! {
  Generic&lt;T&gt;(
    // Generic parameters must be used in an instance field.
    // We can pretend this is the case using a constructor parameter capture.
    // `PhantomData` is a type that provides fake storage semantics.
    priv _phantom: PhantomData&lt;T&gt; = PhantomData::default(),
  )()
  &quot;Generic body.&quot;
}

asteracea::component! {
  Outer()()

  [
    &lt;*Inner /Inner&gt; &quot;\n&quot;
    &lt;*module::Module /Module&gt; &quot;\n&quot;
    &lt;*Generic::&lt;()&gt; /Generic&gt; // 🪣
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Inner body.
Module body.
Generic body.
</code></pre>
<!--
I nearly put the FISHING POLE AND FISH emoji above, but that fest to cruel.
The fish is chilling in a bucket now and will be released into a nicer environment before long.
-->
<p>Using a component multiple times results in distinct instances:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Inner()()
  &quot;Inner body.&quot;
}

asteracea::component! {
  Outer()()
  [
    &lt;*Inner&gt;
    &lt;*Inner&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Inner body.Inner body.
</code></pre>
<h2><a class="header" href="#child-component-instancing" id="child-component-instancing">Child Component Instancing</a></h2>
<blockquote>
<p>Note: Rust is good at erasing empty instances!</p>
<p>If your reused component is stateless, please restate the component's type name instead of using instancing. This will keep your code clearer and less interdependent.</p>
<p>For more information, see <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">The Rustonomicon on Zero Sized Types (ZSTs)</a>.</p>
</blockquote>
<p>Instead of instantiating and storing a child component multiple times, you can instance it by giving it a name and referencing it elsewhere through a Rust block:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: Hide this initially.
asteracea::component! {
  Inner()()
  &quot;Inner body.&quot;
}

asteracea::component! {
  Outer()()
  [
    &lt;*Inner priv inner&gt; // Alternatively: `pub` or `pub(…)`
    &lt;*{self.inner_pinned()}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Inner body.Inner body.
</code></pre>
<p>The component's <code>.render(…)</code> method is called for each of these appearances, but <code>::new(…)</code> is called only once.</p>
<p>Component instancing is especially useful when rendering alternates, since the child instance is available everywhere in the parent component's body (regardless which <code>.render(…)</code> path is taken).</p>
<h1><a class="header" href="#ex-stateless-components-are-zero-sized" id="ex-stateless-components-are-zero-sized">EX: Stateless Components are Zero-Sized</a></h1>
<details>
<summary>This is an optional chapter.</summary>
<blockquote>
<p>EX-chapters don't contain necessary information on how to use Asteracea.</p>
<p>However, they may contain interesting information about performance characteristics or tricks you can use to make your app more maintainable.</p>
</blockquote>
</details>
<p>Consider the following (grasping at <a href="static_components/">constructor parameter</a><a href="static_components/"> captures</a> and <a href="static_components/">value formatting</a> a bit ahead of time):</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::{fmt::Debug, mem::size_of};

asteracea::component! {
  MySize&lt;T: Debug&gt;(
    priv value: T,
  )()

  [
    !&quot;I contain {:?}!&quot;{self.value}
    &quot; My size is &quot; &lt;b !{size_of::&lt;Self&gt;()}&gt; &quot; bytes.&quot;
    !&quot; I'm located at address {:p}.&quot;{self}
  ]
}

asteracea::component! {
  Container()()

  [
    &lt;*MySize::&lt;()&gt; *value = {()}&gt; &quot;\n&quot;
    &lt;*MySize::&lt;()&gt; *value = {()}&gt; &quot;\n&quot;
    &lt;*MySize::&lt;u8&gt; *value = {1}&gt; &quot;\n&quot;
    &lt;*MySize::&lt;usize&gt; *value = {2}&gt; &quot;\n&quot;
    &quot;The container instance occupies &quot; &lt;b !{size_of::&lt;Self&gt;()}&gt; !&quot; bytes at {:p}.&quot;{self}
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">I contain ()! My size is &lt;B&gt;0&lt;/B&gt; bytes. I'm located at address 0x564625f7a280.
I contain ()! My size is &lt;B&gt;0&lt;/B&gt; bytes. I'm located at address 0x564625f7a280.
I contain 1! My size is &lt;B&gt;1&lt;/B&gt; bytes. I'm located at address 0x564625f7a288.
I contain 2! My size is &lt;B&gt;8&lt;/B&gt; bytes. I'm located at address 0x564625f7a280.
The container instance occupies &lt;B&gt;16&lt;/B&gt; bytes at 0x564625f7a280.
</code></pre>
<p>The layout here is somewhat implementation-defined, but generally what you should see is that the <code>MySize::&lt;()&gt;</code> instances take up no space inside the <code>Container</code> instance and don't displace other children in memory.</p>
<p>This is because Asteracea components contain no hidden instance state, which means they are sized to content (and padding requirements), all the way down to zero. <code>()</code> is Rust's <a href="https://doc.rust-lang.org/stable/std/primitive.unit.html">unit</a> type, the most convenient <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">zero sized type</a>. The same applies to components without instance fields, of course.</p>
<p>Zero-sizing is transitive and has many interesting implications, but for our purposes the most notable one is that stateless components are <em>almost</em>¹ function-like at runtime. It's for this reason that Asteracea doesn't provide a special &quot;slim&quot; component syntax.</p>
<blockquote>
<p>¹ There is likely a small amount of overhead during instantiation due to the <a href="static_components/../dynamic_component/dependency_extraction.html">dependency extraction</a> system.
The compiler is in theory allowed to optimise it away, but this isn't guaranteed.</p>
<p>If you have an idea how to make this process meaningfully conditional without changing Asteracea's macro syntax, I'd like to hear about it!</p>
</blockquote>
<h1><a class="header" href="#new-with---" id="new-with---"><code>new with { …; }</code></a></h1>
<!-- The reason for not placing this block after the constructor arguments (without keyword) is that this would create a lot of separation between constructor and render arguments, which should both be visible at a glance when peeking at a component's source code. -->
<p>Arbitrary Rust code can be inserted into a component's constructor using a <code>new with</code>-block:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub Constructed()()

  new with {
    // TODO
  }

  []
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">
</code></pre>
<p>Code inside the <code>new with</code>-block has access to constructor parameters, and <code>let</code>-bindings from this block are in scope for capture initialisers:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub QuoteHolder(
    text: &amp;str,
  )()

  new with {
    let quoted = format!(&quot;‘{}’&quot;, text);
  }

  //TODO:
  // Captures should be legal for all dynamic value expressions…
  // This code will turn into `!|quote: String = { quoted }|` then.
  |quote: String = { quoted }|;

  !{self.quote}
}

asteracea::component! {
  pub Quoter()()

  &lt;*QuoteHolder *text = { &quot;This text is quoted.&quot; }&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">‘This text is quoted.’
</code></pre>
<h1><a class="header" href="#guierror-and-backtrace" id="guierror-and-backtrace"><code>GUIError</code> and <code>&quot;backtrace&quot;</code></a></h1>
<p>The <code>::new(…)</code> and <code>.render(…)</code> functions of Asteracea-components are fallible, returning a <code>Result&lt;_, GUIError&gt;</code>.</p>
<p><a href="dynamic_components/"><code>GUIError</code></a>s are panic-like: They are not expected during normal execution of a web frontend, are strictly deprioritised compared to the <a href="dynamic_components/"><code>Ok</code></a> path and components that catch them are encouraged to implement a &quot;fail once and stop&quot; approach where child components are disposed of on first failure.</p>
<p>As long as Asteracea is compiled with the <code>&quot;backtrace&quot;</code> feature, it will trace <a href="dynamic_components/"><code>GUIError</code></a> propagation through any function instrumented via the <a href="dynamic_components/"><code>#[asteracea::gui_tracing]</code></a> attribute, which is automatic for the two mentioned above.</p>
<p>You can escalate any error along the GUI tree as long as it is <code>Any</code>, <code>Error</code> and <code>Send</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asteracea::error::IntoGUIResult;
use std::error::Error;
use std::fmt::{Display, Formatter, Result};

#[derive(Debug)]
struct AnError;
impl Display for AnError {
  fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
    writeln!(f, &quot;A test error was raised&quot;)
  }
}
impl Error for AnError {}

asteracea::component! {
  Failing()()

  {
    // Raising a `GUIError` means crashing at least part of the app,
    // so there is a speed bump for this conversion.
    return Err(AnError).into_gui_result();
  }
}

asteracea::component! {
  Containing()()

  &lt;*Failing&gt;
}

asteracea::component! {
  pub Outer()()

  &lt;*Containing&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-text">A test error was raised

in Failing :: render
in Containing :: render
in Outer :: render

</code></pre>
<p>These backtraces are for human consumption, so please don't parse them. They may change in any release without notice.</p>
<blockquote>
<p>If the <code>&quot;force-unwind&quot;</code> feature is enabled, <code>GUIError</code>s are erased and the type itself uses the panic infrastructure for propagation instead of being passed up via <a href="dynamic_components/"><code>Err</code></a> variant. This may reduce code size in some cases.</p>
<p>However, note that <strong>panics cannot be caught on platforms without unwinding, including Wasm</strong> (as of Rust 1.49.0).</p>
<p>In the future, panic conversion will be activated automatically on compatible platforms, as long as this can be done without compromising backtraces.</p>
</blockquote>
<h1><a class="header" href="#predefined-lifetimes" id="predefined-lifetimes">Predefined Lifetimes</a></h1>
<p>Asteracea implicitly defines certain user-accessible lifetimes:</p>
<ul>
<li>
<p><code>'a</code> is available in the <code>::new(…)</code> and <code>.render(…)</code> contexts and represents a lower bound of the component's lifetime.</p>
</li>
<li>
<p><code>'bump</code> is the bump allocator lifetime, used when rendering the virtual DOM representation from Asteracea components and only available in the <code>.render(…)</code> context. This is mostly implicit, but you have to specify it in render arguments where references flow into the VDOM.</p>
</li>
</ul>
<p>Overall, the following are true, if types and values represent their lifetimes:</p>
<ul>
<li><code>Self</code> ≥ <code>self</code></li>
<li><code>self</code> == <code>'a</code></li>
<li><code>'a</code> ≥ <code>'bump</code></li>
</ul>
<p>TODO: More details, especially regarding event handlers. Remove <code>Self: 'static</code> constraint.</p>
<h1><a class="header" href="#conditional-attributes" id="conditional-attributes">Conditional Attributes</a></h1>
<p>Asteracea supports conditionally setting optional attributes with the following syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Classic()(
    // This will be improved on in the next chapters.
    class: Option&lt;&amp;'bump str&gt;,
  )

  &lt;div
    .&quot;class&quot;? = {class}
  &gt;
}

asteracea::component! {
  Classical()()

  [
    &lt;*Classic .class = {None}&gt; &quot;\n&quot;
    &lt;*Classic .class = {Some(&quot;classicist&quot;)}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;/DIV&gt;
&lt;DIV class=&quot;classicist&quot;&gt;&lt;/DIV&gt;
</code></pre>
<p>Instead of <a href="dynamic_components/"><code>&amp;'bump str</code></a>, the attribute value type here is <a href="dynamic_components/"><code>Option&lt;&amp;'bump str&gt;</code></a>. If <a href="dynamic_components/"><code>None</code></a> is provided, the attribute is omitted entirely from the rendered VDOM.</p>
<p>This can be used to conditionally render a <a href="https://www.w3.org/TR/html52/infrastructure.html#sec-boolean-attributes">boolean attribute</a> like <code>checked</code>, providing <a href="dynamic_components/"><code>Some(&quot;&quot;)</code></a> to enable the attribute. However, it is usually more convenient to use a <a href="dynamic_components/"><code>bool</code></a> directly:</p>
<h2><a class="header" href="#boolean-attributes" id="boolean-attributes">Boolean Attributes</a></h2>
<p>To make dynamic boolean attributes like <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden"><code>hidden</code></a> more convenient to use, conditional attributes also accept <a href="dynamic_components/"><code>bool</code></a> values directly:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Vis()(
    visible: bool,
  )

  &lt;div
    .&quot;hidden&quot;? = {!visible}
    &quot;#&quot;
  &gt;
}

asteracea::component! {
  Outer()()

  [
    &lt;*Vis .visible = {true}&gt; &quot;\n&quot;
    &lt;*Vis .visible = {false}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;#&lt;/DIV&gt;
&lt;DIV hidden=&quot;&quot;&gt;#&lt;/DIV&gt;
</code></pre>
<p><a href="dynamic_components/"><code>true</code></a> is converted to <a href="dynamic_components/"><code>Some(&quot;&quot;)</code></a> and <a href="dynamic_components/"><code>false</code></a> to <a href="dynamic_components/"><code>None</code></a> in this case, <a href="https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes">as per specification</a>.</p>
<blockquote>
<p>Which types are compatible with conditional attributes is controlled by the <a href="dynamic_components/"><code>ConditionalAttributeValue</code></a> trait.</p>
<p>It is by default implemented for <code>bool</code> and <code>Option&lt;&amp;'bump str&gt;</code>, and I recommend <strong>not</strong> extending this list unless the conversion is very fast.</p>
</blockquote>
<h1><a class="header" href="#argument-defaults" id="argument-defaults">Argument Defaults</a></h1>
<p>Asteracea provides multiple ways to make working with optional arguments easier.</p>
<p>Like in for example TypeScript, you can specify default parameters for constructor and render arguments:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Classic()(
    // This will be improved on in the next chapter.
    class: Option&lt;&amp;'bump str&gt; = None,
  )

  &lt;div
    .&quot;class&quot;? = {class}
  &gt;
}

asteracea::component! {
  Classical()()

  [
    &lt;*Classic&gt; &quot;\n&quot; // Parameter omitted.
    &lt;*Classic .class = {Some(&quot;classicist&quot;)}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;/DIV&gt;
&lt;DIV class=&quot;classicist&quot;&gt;&lt;/DIV&gt;
</code></pre>
<p>Default parameter expressions are normal Rust expressions, and are evaluated as needed if the parameter was not specified.</p>
<!-- TODO: Figure out if default parameter expressions can see other parameters, if yes which, and then clarify that here. --><h1><a class="header" href="#optional-arguments" id="optional-arguments">Optional Arguments</a></h1>
<p>When working with values that may or may not be provided, where the default is outside the range of possible provided values, you can improve your component's interface towards consumers by using optional arguments:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Classic()(
    class?: &amp;'bump str,
  )

  &lt;div
    .&quot;class&quot;? = {class} // `Option&lt;_&gt;`-typed!
  &gt;
}

asteracea::component! {
  Classical()()

  [
    &lt;*Classic&gt; &quot;\n&quot;
    &lt;*Classic .class = {&quot;classicist&quot;}&gt; // Not `Option&lt;_&gt;`-typed!
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;&lt;/DIV&gt;
&lt;DIV class=&quot;classicist&quot;&gt;&lt;/DIV&gt;
</code></pre>
<p><code>class</code> is an <code>Option&lt;&amp;'bump str&gt;</code> within <code>Classic</code>s <code>.render(…)</code> method, but the parameter is provided from outside as <code>&amp;'bump str</code>.</p>
<h1><a class="header" href="#conditional-child-component-parameters" id="conditional-child-component-parameters">Conditional Child Component Parameters</a></h1>
<p>Note that providing optional argument values without <a href="dynamic_components/"><code>Some</code></a> means that <a href="dynamic_components/"><code>None</code></a> can only be specfied by not setting the parameter at all! Fortunately, it's easy to do this conditionally in the same way as for optional attributes on HTML elements:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Inner()(
    class?: &amp;'bump str,
  )

  &lt;span .&quot;class&quot;? = {class}&gt;
}

asteracea::component! {
  Middle()(
    class?: &amp;'bump str,
  )

  &lt;*Inner .class? = {class}&gt;
}

asteracea::component! {
  Outer()()

  [
    &lt;*Middle&gt; &quot;\n&quot;
    &lt;*Middle .class = {&quot;bourgeoisie&quot;}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;SPAN&gt;&lt;/SPAN&gt;
&lt;SPAN class=&quot;bourgeoisie&quot;&gt;&lt;/SPAN&gt;
</code></pre>
<p>This also applies to any other kind of optional parameter, i.e. arguments with explicit default value.</p>
<blockquote>
<p><strong>A note for low-level component implementers</strong></p>
<p>Asteracea, when using child components in templates, constructs parameter bundles using a builder pattern. It assumes that the order of distinctly named parameter assignments does not matter and, in order to reduce code size, moves some assignments of arguments that are assigned to conditionally after those of ones that are not. This is a tradeoff incurred by statically validating parameter list completeness.</p>
<p><strong>Parameter value evaluation order</strong>, assignment order among any unconditionally set parameters, assignment order among conditional parameters <strong>and the order of assignments to the same name are preserved regardless</strong>.</p>
<p>As long as your program compiles, this optimisation is unobservable when handling child component types created using <code>asteracea::component! { … }</code>. You may still want to keep it in mind for components with custom argument builders.</p>
</blockquote>
<h1><a class="header" href="#persistence-2-body-captures" id="persistence-2-body-captures">Persistence 2: Body Captures</a></h1>
<p>TODO: Renamed this to <code>⟦pin⟧ |etc.|</code></p>
<p>TODO</p>
<h1><a class="header" href="#dependency-extraction" id="dependency-extraction">Dependency Extraction</a></h1>
<p>Asteracea natively supports inversion of control via dependency extraction, which is functionally identical to dependency injection but implemented a bit differently.</p>
<p>To define an extractable trait, you can for example write:</p>
<p>TODO</p>
<h1><a class="header" href="#with----" id="with----"><code>with { …; } &lt;…&gt;</code></a></h1>
<p>While you can in theory place nearly any Rust code inside <code>{}</code>-braces as part of Asteracea's grammar, this can be disorderly for more complex calculations or cumbersome where you want to reuse parts of a calculation.</p>
<p>Instead, you can use a <code>with { …; } &lt;…&gt;</code>-expression to run a number of Rust statements procedurally:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub WithExample()()

  with {
    let tree_type = &quot;oak&quot;;
    let leaves_state = &quot;fallen&quot;;
  } &lt;div
    //TODO: .&quot;class&quot; = !&quot;{} {}&quot;{tree_type, leaves_state}
    !&quot;The tree in the garden is an {}.\n&quot;{ tree_type }
    !&quot;The {}'s leaves are {}.&quot;{tree_type, leaves_state} //TODO: Support named formatting parameters.
  &gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;The tree in the garden is an oak.
The oak's leaves are fallen.&lt;/DIV&gt;
</code></pre>
<p><code>with</code>-expressions can be used anywhere an <a href="dynamic_components/*">element expression</a> is expected.</p>
<p>Bindings declared in the <code>with</code>-expression's are only in scope for the embedded <a href="dynamic_components/*">element expression</a>, but with a multi node, you can use them for multiple elements:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  pub WithExample()()

  &lt;div
    with {
      let tree_type = &quot;oak&quot;;
      let leaves_state = &quot;fallen&quot;;
    } [
      !&quot;The tree in the garden is an {}.\n&quot;{ tree_type }
      !&quot;The {}'s leaves are {}.&quot;{tree_type, leaves_state} //TODO: Support named formatting parameters.
    ]
  &gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV&gt;The tree in the garden is an oak.
The oak's leaves are fallen.&lt;/DIV&gt;
</code></pre>
<h1><a class="header" href="#spread-if--" id="spread-if--"><code>spread if {…} &lt;…&gt;</code></a></h1>
<p>To conditionally render a node, you can use <code>spread if</code>-expressions whenever a <a href="conditional_content/"><code>Node&lt;'bump&gt;</code></a> is expected:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Conditional()(
    present: bool,
  )

  spread if {present}
    &quot;I am here.&quot;
}

asteracea::component! {
  Conditioned()()

  [
    &lt;*Conditional .present = {false}&gt;
    &lt;*Conditional .present = {true}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">I am here.
</code></pre>
<p>Note the required curly braces (<code>{}</code>) around the condition and their absence on the body! This is reversed from plain Rust to show that the condition is a Rust expression while the body is not.</p>
<p>To render multiple elements conditionally, use a multi node:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  Conditional()(
    present: bool,
  )

  [
    spread if {present} [ // &lt;-- I recommend formatting this `[]` as you would format `{}` in Rust.
      &quot;I am here&quot;
      &lt;span &quot; and &quot;&gt;
    ]
    &quot;I like this place.&quot;
  ]
}

asteracea::component! {
  Conditioned()()

  [
    &lt;*Conditional .present = {false}&gt; &quot;\n&quot;
    &lt;*Conditional .present = {true}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">I like this place.
I am here&lt;SPAN&gt; and &lt;/SPAN&gt;I like this place.
</code></pre>
<h2><a class="header" href="#pattern-matching-with-let" id="pattern-matching-with-let">Pattern-matching with <code>let</code></a></h2>
<p>is also available, though this means that Asteracea's <code>if</code>-<code>{condition}</code> is <em>not</em> automatically a Rust block. Use <code>{{ statements }}</code> if you really need one, though wrapping the <code>spread if</code> in a <code>with { … } &lt;…&gt;</code>-expression is likely a better idea in terms of code organisation.</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use lignin::{bumpalo::Bump, Node};

asteracea::component! {
  Conditional()(
    content?: &amp;'bump str,
  )

  [
    &quot;[&quot;
    spread if {let Some(content) = content} &lt;div
      !{content}
    &gt;
    &quot;]&quot;
  ]
}

asteracea::component! {
  Conditioned()()

  [
    &lt;*Conditional&gt; &quot;\n&quot;
    &lt;*Conditional .content = {&quot;Content!&quot;}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">[]
[&lt;DIV&gt;Content!&lt;/DIV&gt;]
</code></pre>
<blockquote>
<p><strong>Implicit <code>else</code></strong></p>
<p>If a <code>spread if</code>-expression's condition is not met, an empty <a href="conditional_content/"><code>Node::Multi(…)</code></a> (<code>[]</code>) is rendered by default.</p>
</blockquote>
<!-- intentionally split -->
<blockquote>
<p><strong>A note for React users</strong></p>
<p>Unlike React Hooks, Asteracea's captures (including <code>&lt;*ChildComponent&gt;</code>s) are generally fine to use in conditional <code>spread if</code>-branches, even if which branch is taken changes during the component's lifetime.</p>
<p>The tradeoff for this is that their initialisers always run during component instantiation and that fields are created for any declared captures.</p>
</blockquote>
<h1><a class="header" href="#spread-if--else-" id="spread-if--else-"><code>spread if …… else &lt;…&gt;</code></a></h1>
<p>You can explicitly specify alternative content with an <code>else</code> branch:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Which {
  First,
  Second,
}

asteracea::component! {
  Alternates()(
    show_alternative: bool = false,
  )

  spread if {show_alternative}
    &quot;Default&quot;
  else
    &quot;Alternative&quot;
}

asteracea::component! {
  pub Alternated()()

  [
    &lt;*Alternates&gt; &quot;\n&quot;
    &lt;*Alternates .show_alternative = {true}&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Alternative
Default
</code></pre>
<h1><a class="header" href="#spread-match----" id="spread-match----"><code>spread match &lt;…&gt; [ … ]</code></a></h1>
<p>Rust's <code>match</code> statements are available in Asteracea contexts, with slightly changed syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Enum&lt;'a&gt; {
  Text(&amp;'a str),
  Other,
}

asteracea::component! {
  MatchEnum()(
    enum_value: Enum&lt;'_&gt;,
  )

  spread match {enum_value} [
    Enum::Text(text) =&gt; &lt;span !{text}&gt;
    Enum::Other =&gt; &lt;div .&quot;class&quot; = &quot;placeholder&quot;&gt;
  ]
}

asteracea::component! {
  pub Matched()()

  [
    &lt;*MatchEnum .enum_value = { Enum::Text(&quot;Hello!&quot;) }&gt; &quot;\n&quot;
    &lt;*MatchEnum .enum_value = { Enum::Other }&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;SPAN&gt;Hello!&lt;/SPAN&gt;
&lt;DIV class=&quot;placeholder&quot;&gt;&lt;/DIV&gt;
</code></pre>
<p>Note that the match expression accepts an element expression (<code>&lt;…&gt;</code>) as parameter! If an element renders into something other than a <a href="conditional_content/"><code>Node</code></a>, you can branch on that result this way:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component!{
  Router()() -&gt; &amp;str

  //TODO: Retrieve from fragment.
  { &quot;\0&quot; }
}

impl Router {
  const INDEX: &amp;'static str = &quot;\0&quot;;
}

asteracea::component! {
  RouterUser()()

  spread match &lt;*Router&gt; [
    Router::INDEX | &quot;&quot; =&gt; &quot;Index&quot;
    _ =&gt; {unreachable!()}
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Index
</code></pre>
<h1><a class="header" href="#box-priv--struct--where--" id="box-priv--struct--where--"><code>box ⟦priv …⟦: ⟦struct⟧ … ⟦where …;⟧⟧⟧ &lt;…&gt;</code></a></h1>
<p>A <code>box &lt;…&gt;</code> expression moves its parameter's backing storage into a new heap object, bound to a field of the current <a href="conditional_content/*">storage context</a>.</p>
<p>The field can be named using <code>box priv …</code> syntax. If the field is named, its type can be specified using <code>: …</code>.</p>
<p>If you don't name the type or specify its name using <code>: struct …</code>, it is generated automatically.</p>
<p>The field can be made public by writing <code>box pub …</code>. Any other standard Rust visibility can be used in place of <code>pub</code>, too, to similar effects.</p>
<p>In practical terms:</p>
<ul>
<li>
<p>Any captures are first placed in a <a href="conditional_content/"><code>Box&lt;…&gt;</code></a> before being assigned to a ⟦named⟧ field inside the current component instance.</p>
<p>This means that, for example, if you write <code>box as boxed &lt;*Component as child&gt;</code>, you'll need to access it as <code>self.boxed.child</code>.</p>
<p>This <strong>introduces some level of runtime indirection</strong>, also when rendering components.</p>
</li>
<li>
<p><strong>Uninitialised boxed expressions take up very little space.</strong></p>
</li>
<li>
<p><strong>Recursion becomes possible.</strong></p>
</li>
</ul>
<h2><a class="header" href="#component-recursion" id="component-recursion">Component recursion</a></h2>
<p>Infinite recursive (storage) inlining isn't possible (except <em>theoretically</em> for zero-sized-types, but Rust makes no distinction here).</p>
<p>This means the following requires boxing:</p>
<pre><code class="language-TODOrust TODOasteracea=Countdown asteracea::render=.i(6)">asteracea::component! {
  Countdown()(
    i: usize,
  )

  [
    !{i}
    dyn if {i &gt; 0} [
      &quot;\n&quot;
      box &lt;*Countdown .i = {i - 1}&gt;
    ]
  ]
}
</code></pre>
<blockquote>
<p><strong>Note:</strong></p>
<p>It's decidedly better to implement the above with a loop!<br />
If you have a better example to demonstrate recursion with, please <a href="conditional_content/">let me know</a>!</p>
</blockquote>
<p>Note the use of <code>dyn if</code> to prevent infinite eager initialisation.</p>
<p>You can alternatively combine <code>spread if</code> with <code>lazy ⟦move⟧</code> to avoid throwing away heap allocations once they exist. This is better in cases where the recursion depth changes quickly or </p>
<h2><a class="header" href="#memory-savings" id="memory-savings">Memory savings</a></h2>
<p>The container component size reduction isn't very useful in most cases, since Asteracea initialises child components eagerly, but can be used to great effect with <strong><code>dyn</code> branching if certain arms require especially large storage</strong>.</p>
<!-- TODO: Check if it's possible to let Clippy warn about that. -->
<p>Consider the following:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{MaybeUninit, size_of};

asteracea::component! {
  Heavy()()

  |large: [u8; 1_000] = {[0; 1_000]}|; // 1 KB
  &quot;Hello!&quot;
}

asteracea::component! {
  Holder()(
    show: bool = false,
  )

  [
    &quot;Holder size: &quot; !{size_of::&lt;Self&gt;()} &quot; bytes&quot;
    spread if {show} //TODO: Replace `spread` with `dyn`!
      &lt;*Heavy&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Holder size: 1000 bytes
</code></pre>
<p>As you can see, <code>Holder</code> requires 1KB of space even though <code>Heavy</code> is never used.</p>
<p>You can avoid this as follows:</p>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem::{MaybeUninit, size_of};

asteracea::component! {
  Heavy()()

  |large: [u8; 1_000] = {[0; 1_000]}|; // 1 KB
  &quot;Hello!&quot;
}

asteracea::component! {
  Holder()(
    show: bool = false,
  )

  [
    &quot;Holder size: &quot; !{size_of::&lt;Self&gt;()} &quot; bytes&quot;
    spread if {show} //TODO: Replace `spread` with `dyn`!
      box &lt;*Heavy&gt;
  ]
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">Holder size: 8 bytes
</code></pre>
<p>As <code>dyn if</code> won't initialise its branches unless necessary, no heap allocation happens in this case either.</p>
<!-- TODO: Is there any way to demo this? -->
<h1><a class="header" href="#defer-move-as--" id="defer-move-as--"><code>defer ⟦move⟧ ⟦as …⟧ &lt;…&gt;</code></a></h1>
<p>An alternative method of breaking up recursive component initialisation is to defer it for the recursive part of the template until it is rendered.</p>
<p>As such, the recursive example from the <a href="conditional_content/./box_as.html"><code>box ⟦as …⟧ &lt;…&gt;</code> chapter</a> can be written as:</p>
<pre><code class="language-TODOrust TODOasteracea=Countdown asteracea::render=.i(6)">asteracea::component! {
  Countdown()(
    i: usize,
  )

  [
    !{i}
    spread if {i &gt; 0} [
      &quot;\n&quot;
      defer box &lt;*Countdown .i = {i - 1}&gt;
    ]
  ]
}
</code></pre>
<p>This has different runtime characteristics:</p>
<p><code>spread if</code> doesn't drop branches that aren't active, and <code>defer</code> only ever runs initialisers once. This means that <strong>state persists</strong> and <strong>heap allocations are cached</strong>. Useful for (very) frequently updated content!</p>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h2><a class="header" href="#element-expression" id="element-expression">element expression</a></h2>
<p>Asteracea's most generic template building block. Placeholder: <code>&lt;…&gt;</code></p>
<h1><a class="header" href="#chapter-1-hello-asteracea" id="chapter-1-hello-asteracea">Chapter 1: Hello Asteracea</a></h1>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asteracea::component! {
  HelloAsteracea()()
  &lt;span &quot;Hello Asteracea!&quot;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;SPAN&gt;Hello Asteracea!&lt;/SPAN&gt;
</code></pre>
<pre><pre class="playground"><code class="language-rust no_run ro_playground">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use asteracea::component;
use std::cell::Cell;

fn schedule_render() { /* ... */ }

component! {
  pub Counter(
    initial: i32,
    priv step: i32,
  )(
    /// This component's class attribute value.
    class?: &amp;'bump str,
  )

  |value = Cell::&lt;i32&gt;::new(initial)|; // shorthand capture

  &lt;div
    .&quot;class&quot;? = {class}
    &quot;The current value is: &quot; !{self.value()} &lt;br&gt; // Anything within curlies is plain Rust.

    &lt;button
      &quot;+&quot; !{self.step} // shorthand bump_format call
      +&quot;click&quot; {
        self.value.set(self.value() + self.step);
        schedule_render();
      }
    &gt;
  &gt;
}

impl Counter {
  pub fn value(&amp;self) -&gt; i32 {
    self.value.get()
  }

  pub fn set_value(&amp;self, value: i32) {
    self.value.set(value);
  }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-html">&lt;DIV class=&quot;counter-class&quot;&gt;The current value is: 0&lt;BR&gt;&lt;BUTTON&gt;+1&lt;/BUTTON&gt;&lt;/DIV&gt;
</code></pre>
<!-- markdownlint-disable no-inline-html -->
<div class="subtlish">
<style>
.subtlish {
  height: 0px;
}
</style>
<br><br><br><br><br><br><br><br>
<p>🌬️🍃🌄<br />
🏞️🐟🪣</p>
</div>
<!-- markdownlint-enable no-inline-html -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
