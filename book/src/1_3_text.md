# Chapter 1.3: Text

To output a static plain [`Text`] element in Asteracea, simply use a text literal in your component's body:

[`Text`]: https://developer.mozilla.org/en-US/docs/Web/API/Text

```rust asteracea=Text::new() asteracea::render=.render()
asteracea::component! {
  pub Text()()

  "This is text."
}
```

The macro output is largely the same as for the `Empty` component, but the `render` method has changed:

```rust
use asteracea::lignin_schema::lignin::Node;

# pub struct Text {}
# impl Text {
# pub fn new() -> Self {
#   Self {}
# }
// …
pub fn render(&self) -> Node<'static> {
  (Node::Text("This is text."))
}
// …
# }
```

(Click the eye icon to view the rest of the macro output. Note that this also displays a hidden `main` method inserted by mdBook which isn't part of `component!`'s output.)

Most notably, the method now doesn't take a `bump` parameter and returns `Node<'static>` instead of `Node<'bump>`. This is because rendering static text doesn't require an allocation, because the returned [`Node`] can simply refer to the `str` embedded in the executable's data section.

The method consequently also lost its generic lifetime parameter.

## Multiple `Text` elements

Text nodes can be used as children of other nodes, for example a Multi Node:

```rust asteracea=TextMulti::new()
asteracea::component! {
  pub TextMulti()()

  [
    "This is text."
    "This is also text."
  ]
}
```

```rust
use asteracea::lignin_schema::lignin::{bumpalo::Bump, Node};

# pub struct TextMulti {}
# impl TextMulti {
#     pub fn new() -> Self {
#         Self {}
#     }
// …
pub fn render<'bump>(
    &self,
    bump: &'bump Bump,
) -> Node<'bump> {
    (Node::Multi(&*bump.alloc_with(|| {
        [
            Node::Text("This is text."),
            Node::Text("This is also text."),
        ]
    })))
}
// …
# }
```

Two observations:

- There is no space between the sentences in the HTML output.

- `render` has returned to its previous signature and allocates inside `bump` again.

Asteracea gives you fairly precise control over the output, but that also means it won't make changes to the document's whitespace for you. If there's no whitespace in the literal in the input, then there won't be whitespace in the content of the output (when rendering with [lignin-html] or [lignin-dom]).

[lignin-html]: https://github.com/Tamschi/lignin-html
[lignin-dom]: https://github.com/Tamschi/lignin-dom

There is one important difference between the HTML and DOM output of adjacent sibling Text nodes: In HTML, it is impossible to distinguish them and browsers will parse them as single DOM node. When manipulating the DOM directly, the distinct text nodes will be preserved.

This is one of the reasons that a client-side renderer must once parse the existing DOM into a VDOM when hydrating an app. Another good reason is that user-supplied browser extensions may have made changes to the DOM tree.

(Please don't render into `<body>` directly! Many browser extensions insert their own scripts or overlays as child elements here.

While it's not too likely that these additions will make your app crash, the GUI may glitch and appear for example duplicated. Rendering into, for example, a `<div id=app>` instead is more reliable.)

Multi Nodes generated by Asteracea macros always place their contents in the bump allocation arena, even if those contents are theoretically immutable.
